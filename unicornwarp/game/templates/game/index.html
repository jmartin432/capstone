<html>
<head>
    <meta charset="UTF-8" />
    <title>Unicorn Warp!!!</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/4.0.1/math.min.js"></script>

    {% load static %}

    <link rel="stylesheet" type="text/css" href="{% static 'game/game.css' %}" />


</head>

<body>
    <div id="app">
        <table>
            <tr>
                <td>
                    <div id="output">
                        <svg id="main_svg" width="400" height="400">
                            <g class="prey" v-for="prey in preys" v-bind:transform="transformString(prey)" v-bind:id="prey.id">
                                <path v-bind:d="pathString(prey)" stroke="black" fill="plum" stroke_width="1"></path>
                            </g>
                            <g class="predator" v-for="predator in predators" v-bind:transform="transformString(predator)" v-bind:id="predator.id">
                                <path v-bind:d="pathString(predator)" stroke="black" fill="blue" stroke_width="1"></path>
                            </g>
                        </svg>
                    </div>
                </td>
                <td>
                    <div id="controls">
                        <button v-on:click="play" :disabled=disablePlay>Play</button>
                        <button v-on:click="pause" :disabled=disablePause>Pause</button>
                        <button v-on:click="reset">Reset</button><br>
                        <span>Initial Prey Population: <% initialPreyPop %></span><br>
                        <input type="range" min="1" max="100" v-model="initialPreyPop"><br>
                        <span>Initial Predator Population: <% initialPredPop %></span><br>
                        <input type="range" min="1" max="10" v-model="initialPredPop"><br>
                        <span>Alignment Radius: <% alignmentRadius %></span><br>
                        <input type="range" min="1" max="100" v-model="alignmentRadius"><br>
                        <span>Alignment Weight: <% alignmentWeight %></span><br>
                        <input type="range" min=".1" max="1" step=".1" v-model="alignmentWeight"><br>
                        <span>Avoidance Radius: <% avoidanceRadius %></span><br>
                        <input type="range" min="1" max="100" v-model="avoidanceRadius"><br>
                        <span>Avoidance Weight: <% avoidanceWeight %></span><br>
                        <input type="range" min=".1" max="1" step=".1" v-model="avoidanceWeight"><br>
                        <span>Cohesion Radius: <% cohesionRadius %></span><br>
                        <input type="range" min="1" max="100" v-model="cohesionRadius"><br>
                        <span>Cohesion Weight: <% cohesionWeight %></span><br>
                        <input type="range" min=".1" max="1" step=".1" v-model="cohesionWeight"><br>
                        <span>Current Prey Population: <% preys.length %></span><br>
                        <span>Current Tick: <% tick %></span><br>
                    </div>
                </td>
            </tr>
        </table>

    </div>




<script>

    let animationId = "";

    function getAverageVelocity(agentList){
        let velocitySum = new Vector (0,0);
        for (let i = 0; i < agentList.length; i++){
            velocitySum.x += agentList[i].velocity.x;
            velocitySum.y += agentList[i].velocity.y
        }
        velocitySum.scaleBy(1 / agentList.length);
        // velocitySum.normalize();
        return velocitySum;
    }

    // Agent Class
    class Agent {
        constructor(id, pos, vel, scale_factor, speed_factor, color) {
            this.id = id;
            this.position = pos;
            this.velocity = vel;
            this.acceleration = new Vector (0,0);
            this.targetVel = new Vector (this.velocity.x, this.velocity.y);
            this.scaleFactor = scale_factor;
            this.speedFactor = speed_factor;
            this.color = color;
            this.neighbors = [];

        }

        outOfBounds(){
            if (this.position.x < 20 && this.velocity.x < 0) {
                return true;
            }

            else if (this.position.x > 380 && this.velocity.x > 0) {
                return true;
            }
            else if (this.position.y < 20 && this.velocity.y < 0) {
                return true;
            }
            else if (this.position.y > 380 && this.velocity.y > 0) {
                return true;
            }
            return false;
        }

        updateOutOfBoundsVelocity(){
            if (this.position.x < 20 && this.velocity.x < 0) {
                this.targetVel.x = -1 * this.velocity.x;
            }

            else if (this.position.x > 380 && this.velocity.x > 0) {
                this.targetVel.x = -1 * this.velocity.x;
            }
            else if (this.position.y < 20 && this.velocity.y < 0) {
                this.targetVel.y = -1 * this.velocity.y;
            }
            else if (this.position.y > 380 && this.velocity.y > 0) {
                this.targetVel.y = -1 * this.velocity.y;
            }
            this.acceleration = Vector.difference(this.targetVel, this.velocity);
            this.acceleration.scaleBy(0.1);
        }


        findPredatorNeighbors(){
            this.neighbors = [];
            for (let i = 0; i < app.predators.length; i++) {
                if (this === app.predators[i]){
                    continue;
                }
                if (Vector.distanceSquared(app.predators[i].position, this.position) < (app.alignmentRadius * app.alignmentRadius)) {
                    this.neighbors.push(app.predators[i]);

                }
            }
        }
        findPreyNeighbors(){
            this.neighbors = [];
            for (let i = 0; i < app.preys.length; i++) {
                if (this === app.preys[i]){
                    continue;
                }
                if (Vector.distanceSquared(app.preys[i].position, this.position) < (app.alignmentRadius * app.alignmentRadius)) {
                    this.neighbors.push(app.preys[i]);

                }
            }
        }

        getRandomVelocity(){
            this.targetVel.x = this.velocity.x + (Math.random() - .5);
            this.targetVel.y = this.velocity.y + (Math.random() - .5);
        }

        updateAcceleration(){
            this.acceleration = Vector.difference(this.targetVel, this.velocity);
            this.acceleration.scaleBy(0.1);
        }



        getBearing (){
            return Math.atan2(this.velocity.y, this.velocity.x) * 180 / Math.PI;
        }

        getScaleFactor (){
            return this.scaleFactor;
        }

        updateVelocity (){
            this.velocity.add(this.acceleration);
            this.velocity.normalize();
        }
        updatePosition (){
            this.position.add(this.velocity);
        }

        setAcceleration (v1){
            this.acceleration = v1;
        }

        resetAcceleration (){
            this.acceleration.x = 0;
            this.acceleration.y = 0;
        }

    }


    // Vector Class
    class Vector {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        reset () {
            this.x = 0;
            this.y = 0;
        }

        equals(v1){
            if (this.x === v1.x && this.y === v1.y){
                return true;
            }
            return false;
        }

        round(v1){

        }

        normalize (){
            let mag = this.magnitude();
            if (mag === 0){
                return;
            }
            return this.scaleBy(1 / mag);

        }

        magnitude (){
            return Math.sqrt(((this.x) * (this.x) + (this.y) * (this.y)));

        }

        scaleBy (val){
             this.x *= val;
             this.y *= val;

        }

        setX (val){
            this.x = val;
        }

        setY (val){
            this.y = val;
        }

        getX (){
            return this.x
        }

        getY (){
            return this.y
        }



        add (v1) {
            this.x += v1.x;
            this.y += v1.y;
        }

        static difference (v1, v2){
            return new Vector (v1.x - v2.x, v1.y - v2.y);
        }

        static distanceSquared (v1, v2){
            return ((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y));
        }

        static distance (v1, v2) {
            return Math.sqrt(((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y)));
        }
    }


    function getAvoidanceVelocity(agent){
        let difference = new Vector (0,0);
        let velocityToNeighbor = new Vector (0,0);
        let velocitySum = new Vector (0,0);
        for (let i = 0; i < agent.neighbors.length; i++){
            if (Vector.distanceSquared(agent.position, agent.neighbors[i].position) < app.avoidanceRadius * app.avoidanceRadius) {
                velocityToNeighbor = Vector.difference(agent.neighbors[i].position, agent.position);
                velocityToNeighbor.scaleBy(-1);
                velocitySum.add(velocityToNeighbor);
            }
        }
        velocitySum.normalize();
        return velocitySum;
    }

    function getAlignmentVelocity(agent){
        let velocitySum = new Vector (0,0);
        for (let i = 0; i < agent.neighbors.length; i++){
            velocitySum.add(agent.neighbors[i].velocity);
        }
        velocitySum.scaleBy(1 / agent.neighbors.length);
        velocitySum.normalize();
        return velocitySum;
    }

    function getCohesionVelocity(agent){
        let positionSum = new Vector (0,0);

        for (let i = 0; i < agent.neighbors.length; i++){
            positionSum.add(agent.neighbors[i].position);
        }
        positionSum.scaleBy(1 / agent.neighbors.length);
        let vectorToCenter = Vector.difference(positionSum, agent.position);
        vectorToCenter.normalize();
        return vectorToCenter;
    }



    var app = new Vue({
        el: '#app',
        data: {
            predators: [],
            preys: [],
            animating: false,
            cohesionOn: true,
            avoidanceOn: true,
            alignmentOn: true,
            agentSpeed: 1,
            animationRate: 1,
            initialPreyPop: 50,
            initialPredPop: 4,
            population: 0,
            alignmentRadius: 50,
            alignmentWeight: 1,
            avoidanceWeight: 1,
            avoidanceRadius: 20,
            cohesionWeight: 1,
            cohesionRadius: 50,
            tick: 0,
            updateRate: 10,
        },

        delimiters: ["<%","%>"],

        methods: {
            transformString: function (agent) {
                return "translate(" + agent.position.getX() + "," + agent.position.getY() + ")rotate(" + agent.getBearing() + ")scale(" + agent.getScaleFactor() + ")";
            },

            pathString: function (agent) {
                return "m20,0l-20,10l-10,-10l10,-10l20,10";
            },

            colorString: function (agent) {
                return agent.color;
            },

            createAgents: function () {
                for (let i = 0; i < this.initialPredPop; i++) {
                    let id = i;
                    let position = new Vector(Math.floor(Math.random() * 350 + 25), Math.floor(Math.random() * 350 + 25));
                    let velocity = new Vector((Math.random() * 2 - 1), (Math.random() * 2 - 1));
                    velocity.normalize();
                    let color = "red";
                    let predator = new Agent(id, position, velocity, .7, 2, "blue");
                    this.predators.push(predator);
                }
                for (let i = 0; i < this.initialPreyPop; i++) {
                    let id = i;
                    let position = new Vector(Math.floor(Math.random() * 350 + 25), Math.floor(Math.random() * 350 + 25));
                    let velocity = new Vector((Math.random() * 2 - 1), (Math.random() * 2 - 1));
                    velocity.normalize();
                    let color = "plum";
                    let prey = new Agent(id, position, velocity, .4, 2, "plum");
                    this.preys.push(prey);
                }
            },

            updateAgents: function () {
                let predator = {};
                let prey = {};
                let avoidanceVelocity = new Vector (0, 0);
                let alignmentVelocity = new Vector (0, 0);
                let cohesionVelocity = new Vector (0, 0);



                if (this.animating) {
                    window.requestAnimationFrame(this.updateAgents);
                    this.tick++;
                }

                for (let i = 0; i < this.predators.length; i ++){
                    predator = this.predators[i];
                    if (predator.id % 10 === this.tick % 10) {
                        predator.targetVel.reset();
                        predator.acceleration.reset();
                        if (predator.outOfBounds()) {
                            predator.updateOutOfBoundsVelocity();
                            predator.updateAcceleration();
                        }
                        else {
                            predator.findPredatorNeighbors();
                            if (predator.neighbors.length > 0){
                                avoidanceVelocity = getAvoidanceVelocity(predator);
                                console.log("avoid vel", avoidanceVelocity);
                                console.log(predator.neighbors);
                                predator.targetVel.add(avoidanceVelocity);
                                predator.targetVel.normalize();
                                predator.updateAcceleration();
                            }
                            else{
                                predator.getRandomVelocity();
                                predator.updateAcceleration();
                            }
                        }
                    }
                    predator.updateVelocity();
                    predator.updatePosition();
                }

                for (let i = 0; i < this.preys.length; i++) {
                    prey = this.preys[i];

                    if (prey.id % 10 === this.tick % 10){
                        prey.neighbors = [];
                        prey.targetVel.reset();
                        prey.acceleration.reset();
                        if (prey.outOfBounds()){
                            prey.updateOutOfBoundsVelocity();
                            prey.updateAcceleration();
                        }
                        else {
                            prey.findPreyNeighbors();
                            if (prey.neighbors.length > 0){
                                avoidanceVelocity = getAvoidanceVelocity(prey);
                                avoidanceVelocity.scaleBy(this.avoidanceWeight);
                                alignmentVelocity = getAlignmentVelocity(prey);
                                alignmentVelocity.scaleBy(this.alignmentWeight);
                                cohesionVelocity = getCohesionVelocity(prey);
                                cohesionVelocity.scaleBy(this.cohesionWeight);
                                prey.targetVel.add(avoidanceVelocity);
                                prey.targetVel.add(alignmentVelocity);
                                prey.targetVel.add(cohesionVelocity);
                                prey.targetVel.normalize();
                                prey.updateAcceleration();
                            }
                            else {
                                prey.getRandomVelocity();
                                prey.updateAcceleration();
                            }
                        }
                    }

                    prey.updateVelocity();
                    prey.updatePosition();

                }
            },

             play: function(){
                this.animating = true;
                animationId = window.requestAnimationFrame(this.updateAgents);
            },

            pause: function(){
                this.animating = false;
            },

            reset: function(){
                this.animating = false;

                window.cancelAnimationFrame(animationId);
                this.preys = [];
                this.predators = [];
                this.tick = 0;
                app.createAgents();
            },

        },

        computed: {
            disablePlay: function(){
                return this.animating;
            },

            disablePause: function(){
                return !this.animating;
            },
        },
    });


    app.createAgents();


</script>
</body>
</html>



