<html>
<head>
    <meta charset="UTF-8" />
    <title>Unicorn Warp!!!</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/4.0.1/math.min.js"></script>

    {% load static %}

    <link rel="stylesheet" type="text/css" href="{% static 'game/game.css' %}" />


</head>

<body>
    <div id="app">
        <table>
            <tr>
                <td>
                    <div id="output">
                        <svg id="main_svg" width="400" height="400">
                            <g class="agent" v-for="agent in agents" v-bind:transform="transformString(agent)" v-bind:id="agent.id">
                                <path v-bind:d="pathString(agent)" stroke="black" fill="plum" stroke_width="1"></path>
                            </g>
                        </svg>
                    </div>
                </td>
                <td>
                    <div id="controls">
                        <button v-on:click="play" :disabled=disablePlay>Play</button>
                        <button v-on:click="pause" :disabled=disablePause>Pause</button>
                        <button v-on:click="reset">Reset</button><br>
                        <span>Initial Population: <% initial_population %></span><br>
                        <input type="range" min="5" max="100" v-model="initial_population"><br>
                        <span>Alignment Radius: <% alignment_radius %></span><br>
                        <input type="range" min="30" max="100" v-model="alignment_radius"><br>
                        <span>Separation Radius: <% separationRadius %></span><br>
                        <input type="range" min="1" max="10" v-model="separationRadius"><br>
                        <span>Separation Weight: <% separation_weight %></span><br>
                        <input type="range" min=".01" max="5" step=".1" v-model="separation_weight"><br>
                        <span>Cohesion Radius: <% cohesion_radius %></span><br>
                        <input type="range" min="5" max="100" v-model="cohesion_radius"><br>
                        <span>Cohesion Weight: <% cohesion_weight %></span><br>
                        <input type="range" min=".01" max="5" step=".1" v-model="cohesion_weight"><br>
                        <span>Current Population: <% agents.length %></span><br>
                        <span>Current Tick: <% tick %></span><br>
                    </div>
                </td>
            </tr>
        </table>

    </div>




<script>

    let animationId = "";

    function getAverageVelocity(agentList){
        let velocitySum = new Vector (0,0);
        for (let i = 0; i < agentList.length; i++){
            velocitySum.x += agentList[i].velocity.x;
            velocitySum.y += agentList[i].velocity.y
        }
        velocitySum.scaleBy(1 / agentList.length);
        // velocitySum.normalize();
        return velocitySum;
    }

    // Agent Class
    class Agent {
        constructor(id, pos, vel, scale_factor, speed_factor, color) {
            this.id = id;
            this.position = pos;
            this.velocity = vel;
            this.acceleration = new Vector (0,0);
            this.targetVel = new Vector (this.velocity.x, this.velocity.y);
            this.scaleFactor = scale_factor;
            this.speedFactor = speed_factor;
            this.color = color;
            this.neighbors = [];

        }

        outOfBounds(){
            if (this.position.x < 20 && this.velocity.x < 0) {
                return true;
            }

            else if (this.position.x > 380 && this.velocity.x > 0) {
                return true;
            }
            else if (this.position.y < 20 && this.velocity.y < 0) {
                return true;
            }
            else if (this.position.y > 380 && this.velocity.y > 0) {
                return true;
            }
            return false;
        }

        updateOutOfBoundsVelocity(){
            if (this.position.x < 20 && this.velocity.x < 0) {
                this.targetVel.x = -1 * this.velocity.x;
            }

            else if (this.position.x > 380 && this.velocity.x > 0) {
                this.targetVel.x = -1 * this.velocity.x;
            }
            else if (this.position.y < 20 && this.velocity.y < 0) {
                this.targetVel.y = -1 * this.velocity.y;
            }
            else if (this.position.y > 380 && this.velocity.y > 0) {
                this.targetVel.y = -1 * this.velocity.y;
            }
            this.acceleration = Vector.difference(this.targetVel, this.velocity);
            this.acceleration.scaleBy(0.1);
        }


        findNeighbors(){
            this.neighbors = [];
            for (let i = 0; i < app.agents.length; i++) {
                if (this === app.agents[i]){
                    continue;
                }
                if (Vector.distanceSquared(app.agents[i].position, this.position) < (app.alignment_radius * app.alignment_radius)) {
                    this.neighbors.push(app.agents[i]);

                }
            }
        }

        getRandomVelocity(){
            this.targetVel.x = this.velocity.x + (Math.random() - .5);
            this.targetVel.y = this.velocity.y + (Math.random() - .5);
        }

        updateAcceleration(){
            this.acceleration = Vector.difference(this.targetVel, this.velocity);
            this.acceleration.scaleBy(0.1);
        }



        getBearing (){
            return Math.atan2(this.velocity.y, this.velocity.x) * 180 / Math.PI;
        }

        getScaleFactor (){
            return this.scaleFactor;
        }

        updateVelocity (){
            this.velocity.add(this.acceleration);
            this.velocity.normalize();
        }
        updatePosition (){
            this.position.add(this.velocity);
        }

        setAcceleration (v1){
            this.acceleration = v1;
        }

        resetAcceleration (){
            this.acceleration.x = 0;
            this.acceleration.y = 0;
        }

    }


    // Vector Class
    class Vector {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        reset () {
            this.x = 0;
            this.y = 0;
        }

        equals(v1){
            if (this.x === v1.x && this.y === v1.y){
                return true;
            }
            return false;
        }

        round(v1){

        }

        normalize (){
            let mag = this.magnitude();
            if (mag === 0){
                return;
            }
            return this.scaleBy(1 / mag);

        }

        magnitude (){
            return Math.sqrt(((this.x) * (this.x) + (this.y) * (this.y)));

        }

        scaleBy (val){
             this.x *= val;
             this.y *= val;

        }

        setX (val){
            this.x = val;
        }

        setY (val){
            this.y = val;
        }

        getX (){
            return this.x
        }

        getY (){
            return this.y
        }



        add (v1) {
            this.x += v1.x;
            this.y += v1.y;
        }

        static difference (v1, v2){
            return new Vector (v1.x - v2.x, v1.y - v2.y);
        }

        static distanceSquared (v1, v2){
            return ((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y));
        }

        static distance (v1, v2) {
            return Math.sqrt(((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y)));
        }
    }


    function getAvoidanceVelocity(agent){
        let difference = new Vector (0,0);
        let velocityToNeighbor = new Vector (0,0);
        let velocitySum = new Vector (0,0);
        for (let i = 0; i < agent.neighbors.length; i++){
            if (Vector.distanceSquared(agent.position, agent.neighbors[i].position) < app.separationRadius) {
                velocityToNeighbor = Vector.difference(agent.neighbors[i].position, agent.position);
                velocityToNeighbor.scaleBy(-1);
                velocitySum.add(velocityToNeighbor);
            }
        }
        velocitySum.normalize();
        return velocitySum;
    }

    function getAlignmentVelocity(agent){
        let velocitySum = new Vector (0,0);
        for (let i = 0; i < agent.neighbors.length; i++){
            velocitySum.add(agent.neighbors[i].velocity);
        }
        velocitySum.scaleBy(1 / agent.neighbors.length);
        velocitySum.normalize();
        return velocitySum;
    }

    function getCohesionVelocity(agent){
        let positionSum = new Vector (0,0);

        for (let i = 0; i < agent.neighbors.length; i++){
            positionSum.add(agent.neighbors[i].position);
        }
        positionSum.scaleBy(1 / agent.neighbors.length);
        let vectorToCenter = Vector.difference(positionSum, agent.position);
        vectorToCenter.normalize();
        return vectorToCenter;
    }



    var app = new Vue({
        el: '#app',
        data: {
            agents: [],
            animating: false,
            animation_rate: 1,
            initial_population: 10,
            population: 0,
            alignment_radius: 50,
            separation_weight: .1,
            separationRadius: 20,
            cohesion_weight: .1,
            cohesion_radius: 50,
            tick: 0,
            updateRate: 10,
        },

        delimiters: ["<%","%>"],

        methods: {
            transformString: function (agent) {
                return "translate(" + agent.position.getX() + "," + agent.position.getY() + ")rotate(" + agent.getBearing() + ")scale(" + agent.getScaleFactor() + ")";
            },

            pathString: function (agent) {
                return "m20,0l-20,10l-10,-10l10,-10l20,10";
            },

            createAgents: function () {
                for (let i = 0; i < this.initial_population; i++) {
                    let id = i;
                    let position = new Vector(Math.floor(Math.random() * 350 + 25), Math.floor(Math.random() * 350 + 25));
                    let velocity = new Vector((Math.random() * 2 - 1), (Math.random() * 2 - 1));
                    velocity.normalize();
                    let color = "plum";
                    let agent = new Agent(id, position, velocity, .4, .5, color);
                    this.agents.push(agent);
                }
            },

            updateAgents: function () {

                let agent = {};
                let avoidanceVelocity = new Vector (0, 0);
                let alignmentVelocity = new Vector (0, 0);
                let cohesionVelocity = new Vector (0, 0);



                if (this.animating) {
                    window.requestAnimationFrame(this.updateAgents);
                    this.tick++;
                }

                for (let i = 0; i < this.agents.length; i++) {
                    agent = this.agents[i];

                    if (agent.id % 10 === this.tick % 10){
                        agent.neighbors = [];
                        agent.targetVel.reset();
                        agent.acceleration.reset();
                        if (agent.outOfBounds()){
                            agent.updateOutOfBoundsVelocity();
                            agent.updateAcceleration();
                        }
                        else {
                            agent.findNeighbors();
                            if (agent.neighbors.length > 0){
                                avoidanceVelocity = getAvoidanceVelocity(agent);
                                alignmentVelocity = getAlignmentVelocity(agent);
                                cohesionVelocity = getCohesionVelocity(agent);
                                agent.targetVel.add(avoidanceVelocity);
                                agent.targetVel.add(alignmentVelocity);
                                agent.targetVel.add(cohesionVelocity);
                                agent.targetVel.normalize();
                                agent.updateAcceleration();
                            }
                            else {
                                agent.getRandomVelocity();
                                agent.updateAcceleration();
                            }
                        }
                    }

                    agent.updateVelocity();
                    agent.updatePosition();

                }
            },

            play: function(){
                this.animating = true;
                animationId = window.requestAnimationFrame(this.updateAgents);
            },

            pause: function(){
                this.animating = false;
            },

            reset: function(){
                this.animating = false;

                window.cancelAnimationFrame(animationId);
                this.agents = [];
                this.tick = 0;
                app.createAgents();
            },

        },

        computed: {
            disablePlay: function(){
                return this.animating;
            },

            disablePause: function(){
                return !this.animating;
            },
        },
    });


    app.createAgents();


</script>
</body>
</html>



