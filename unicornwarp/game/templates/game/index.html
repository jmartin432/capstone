<html>
<head>
    <meta charset="UTF-8" />
    <title>Unicorn Warp!!!</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/4.0.1/math.min.js"></script>

    {% load static %}

    <link rel="stylesheet" type="text/css" href="{% static 'game/game.css' %}" />


</head>

<body>
    <div id="app">
        <table>
            <tr>
                <td>
                    <div id="output">
                        <svg id="main_svg" width="400" height="400">
                            <g class="agent" v-for="agent in agents" v-bind:transform="transformString(agent)" v-bind:id="agent.id">
                                <path v-bind:d="pathString(agent)" stroke="black" fill="plum" stroke_width="1"></path>
                            </g>
                        </svg>
                    </div>
                </td>
                <td>
                    <div id="controls">
                        <button v-on:click="play" :disabled=disablePlay>Play</button>
                        <button v-on:click="pause" :disabled=disablePause>Pause</button>
                        <button v-on:click="reset">Reset</button><br>
                        <span>Initial Population: <% initial_population %></span><br>
                        <input type="range" min="5" max="100" v-model="initial_population"><br>
                        <span>Alignment Radius: <% alignment_radius %></span><br>
                        <input type="range" min="30" max="100" v-model="alignment_radius"><br>
                        <span>Separation Radius: <% separation_radius %></span><br>
                        <input type="range" min="1" max="10" v-model="separation_radius"><br>
                        <span>Separation Weight: <% separation_weight %></span><br>
                        <input type="range" min=".01" max="5" step=".1" v-model="separation_weight"><br>
                        <span>Cohesion Radius: <% cohesion_radius %></span><br>
                        <input type="range" min="5" max="100" v-model="cohesion_radius"><br>
                        <span>Cohesion Weight: <% cohesion_weight %></span><br>
                        <input type="range" min=".01" max="5" step=".1" v-model="cohesion_weight"><br>
                        <span>Current Population: <% agents.length %></span><br>
                        <span>Current Tick: <% tick %></span><br>
                    </div>
                </td>
            </tr>
        </table>

    </div>




<script>

    let animationId = "";

    // Agent Class
    class Agent {
        constructor(id, pos, vel, scale_factor, speed_factor, color) {
            this.id = id;
            this.position = pos;
            this.velocity = vel;
            this.acceleration = new Vector (0,0);
            this.targetVel = new Vector (this.velocity.x, this.velocity.y);
            this.scaleFactor = scale_factor;
            this.speedFactor = speed_factor;
            this.color = color;
            this.neighbors = [];

        }

        outOfBounds(){
            if (this.position.x < 20 && this.velocity.x < 0) {
                this.targetVel.x = -1 * this.velocity.x;
                this.acceleration = Vector.difference(this.targetVel, this.velocity);
                this.acceleration.scaleBy(0.1);
                return true;
            }

            else if (this.position.x > 380 && this.velocity.x > 0) {
                this.targetVel.x = -1 * this.velocity.x;
                this.acceleration = Vector.difference(this.targetVel, this.velocity);
                this.acceleration.scaleBy(0.1);
                return true;
            }
            else if (this.position.y < 20 && this.velocity.y < 0) {
                this.targetVel.y = -1 * this.velocity.y;
                this.acceleration = Vector.difference(this.targetVel, this.velocity);
                this.acceleration.scaleBy(0.1);
                return true;
            }
            else if (this.position.y > 380 && this.velocity.y > 0) {
                this.targetVel.y = -1 * this.velocity.y;
                this.acceleration = Vector.difference(this.targetVel, this.velocity);
                this.acceleration.scaleBy(0.1);
                return true;
            }
            return false;

        }



        getBearing (){
            return Math.atan2(this.velocity.y, this.velocity.x) * 180 / Math.PI;
        }

        getScaleFactor (){
            return this.scaleFactor;
        }

        updateVelocity (){
            this.velocity.add(this.acceleration);
            this.velocity.normalize();
        }
        updatePosition (){
            this.position.add(this.velocity);
        }

        setAcceleration (v1){
            this.acceleration = v1;
        }

        resetAcceleration (){
            this.acceleration.x = 0;
            this.acceleration.y = 0;
        }

    }


    // Vector Class
    class Vector {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        equals(v1){
            if (this.x === v1.x && this.y === v1.y){
                return true;
            }
            return false;
        }

        round(v1){

        }

        normalize (){
            let mag = this.magnitude();
            if (mag === 0){
                return;
            }
            return this.scaleBy(1 / mag);

        }

        magnitude (){
            return Math.sqrt(((this.x) * (this.x) + (this.y) * (this.y)));

        }

        scaleBy (val){
             this.x *= val;
             this.y *= val;

        }

        setX (val){
            this.x = val;
        }

        setY (val){
            this.y = val;
        }

        getX (){
            return this.x
        }

        getY (){
            return this.y
        }



        add (v1) {
            this.x += v1.x;
            this.y += v1.y;
        }

        static difference (v1, v2){
            return new Vector (v1.x - v2.x, v1.y - v2.y);
        }

        static distanceSquared (v1, v2){
            return ((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y));
        }

        static distance (v1, v2) {
            return Math.sqrt(((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y)));
        }


    }



    var app = new Vue({
        el: '#app',
        data: {
            agents: [],
            animating: false,
            animation_rate: 1,
            initial_population: 10,
            population: 0,
            alignment_radius: 100,
            separation_weight: .1,
            separation_radius: 20,
            cohesion_weight: .1,
            cohesion_radius: 50,
            tick: 0,
            updateRate: 10,
        },

        delimiters: ["<%","%>"],

        methods: {
            transformString: function (agent) {
                return "translate(" + agent.position.getX() + "," + agent.position.getY() + ")rotate(" + agent.getBearing() + ")scale(" + agent.getScaleFactor() + ")";
            },

            pathString: function (agent) {
                return "m20,0l-20,10l-10,-10l10,-10l20,10";
            },

            createAgents: function () {
                for (let i = 0; i < this.initial_population; i++) {
                    let id = i;
                    let position = new Vector(Math.floor(Math.random() * 350 + 25), Math.floor(Math.random() * 350 + 25));
                    let velocity = new Vector((Math.random() * 2 - 1), (Math.random() * 2 - 1));
                    velocity.normalize();
                    let color = "plum";
                    let agent = new Agent(id, position, velocity, .4, .5, color);
                    this.agents.push(agent);
                }
            },

            updateAgents: function () {

                let agent = {};
                let acceleration = new Vector;

                if (this.animating) {
                    window.requestAnimationFrame(this.updateAgents);
                    this.tick++;
                }

                for (let i = 0; i < this.agents.length; i++) {
                    agent = this.agents[i];

                    if (agent.id % 10 === this.tick % 10){
                        agent.resetAcceleration();
                        if (agent.outOfBounds()){
                            agent.updateVelocity();
                            agent.updatePosition();
                        }
                        else {

                            agent.updateVelocity();
                            agent.updatePosition();

                        }
                        // Get a new target velocity every 10th frame

                    }
                    else{
                        agent.updateVelocity();
                        agent.updatePosition();
                    }




                }

            },

            play: function(){
                this.animating = true;
                animationId = window.requestAnimationFrame(this.updateAgents);
            },

            pause: function(){
                this.animating = false;
            },

            reset: function(){
                this.animating = false;

                window.cancelAnimationFrame(animationId);
                this.agents = [];
                this.tick = 0;
                app.createAgents();
            },

        },

        computed: {
            disablePlay: function(){
                return this.animating;
            },

            disablePause: function(){
                return !this.animating;
            },
        },
    });


    app.createAgents();

// for (let i = 0; i < this.population; i++) {
                        //     if (i === j) {
                        //         continue;
                        //     }
                        //     if (math.distance(agent.pos, this.agents[i].pos) <= this.alignment_radius) {
                        //         neighbors.push(this.agents[i]);
                        //     }
                        //
                        // }


                        //if the agent has neighbors then find the new velocity vector
                        // if (neighbors.length > 0) {
                        //     agent.getNewVelocity(neighbors);
                        //
                        //     // agent.vel = math.add(agent.vel, agent.getSeparationAcc(separation_neighbors, this.separation_weight));
                        //
                        //     // agent.vel = math.add(agent.vel, agent.getCohesionAcc(cohesion_neighbors, this.cohesion_weight));
                        //
                        // }
                        // velocity_magnitude = math.distance(agent.vel, [0, 0]);
                        // agent.vel = math.divide(agent.vel, velocity_magnitude);
                        //
                        // if (agent.pos[0] + agent.vel[0] <= 20 || agent.pos[0] + agent.vel[0] >= 380) {
                        //     agent.vel[0] *= -1;
                        // }
                        // if (agent.pos[1] + agent.vel[1] <= 20 || agent.pos[1] + agent.vel[1] >= 380) {
                        //     agent.vel[1] *= -1;
                        // }
                        //
                        // agent.bearing = Math.atan2(agent.vel[1], agent.vel[0]) * 180 / Math.PI;
                        // agent.pos = math.add(agent.pos, math.multiply(agent.vel, agent.speed_factor));

                    // }

                    // velocity_magnitude = math.distance(agent.vel, [0, 0]);
                    // agent.vel = math.divide(agent.vel, velocity_magnitude);
                    //
                    //
                    //



    <!--getCohesionAcc (neighbors, weight){-->
        //     let position_sum = [0, 0], count = 0, group_center = [], difference = [0, 0];
        //     if (neighbors.length === 0){
        //         return [0, 0];
        //     }
        //     else{
        //         for(let i = 0; i < neighbors.length; i++){
        //             position_sum = math.add(position_sum, neighbors[i].pos);
        //             count++;
        //         }
        //         group_center = math.divide(position_sum, count);
        //         difference = math.subtract(group_center, this.pos);
        //         return math.multiply(difference, weight);
        //     }
        //
        // }
        //
        // getSeparationAcc (neighbors, weight) {
        //     let acceleration = [0, 0], difference = [0, 0];
        //     if (neighbors.length === 0) {
        //         return acceleration;
        //     }
        //     else {
        //         for (let i = 0; i < neighbors.length; i++) {
        //             difference = math.subtract(this.pos, neighbors[i].pos);
        //             acceleration = math.add(acceleration, difference);
        //         }
        //     }
        //     return math.multiply(acceleration, weight);
        // }

// getNewVelocity (neighbors){
        //     let velocity_sum = this.vel;
        //     let position_sum = [0, 0];
        //     let count = 1;
        //     let vectorToCOM = [0, 0];
        //     let newVelocity = [];
        //     let separationAcceleration = [0, 0];
        //     let difference = [0, 0];
        //     let centerOfMass = [0, 0];
        //     let cohesionAcceleration = [0, 0];
        //
        //
        //     for(let i = 0; i < neighbors.length; i++){
        //         velocity_sum = math.add(velocity_sum, neighbors[i].vel);
        //         position_sum = math.add(position_sum, neighbors[i].pos);
        //         count++;
        //         if (math.distance(this.pos, neighbors[i].pos) <= app.separation_radius){
        //             difference = math.subtract(this.pos, neighbors[i].pos);
        //             separationAcceleration = math.add(separationAcceleration, difference);
        //         }
        //     }
        //     separationAcceleration = math.multiply(separationAcceleration, app.separation_weight);
        //     newVelocity = math.divide(velocity_sum, count);
        //     centerOfMass = math.divide(position_sum, count-1);
        //     vectorToCOM = math.subtract(centerOfMass, this.pos);
        //     // cohesionAcceleration = math.multiply(vectorToCOM, app.cohesion_weight);
        //     newVelocity = math.add(newVelocity, separationAcceleration);
        //     // newVelocity = math.add(newVelocity, cohesionAcceleration);
        //
        //     this.vel = newVelocity;

    // let agent = {};
                // let neighbors = [];
                // let acceleration = [];

                // for (let j = 0; j < this.population; j++) {
                // agent = this.agents[j];
                // neighbors = [];
                //
                // if (agent.vel != agent.targetVel){
                //     acceleration = math.subtract(agent.targetVel, agent.vel);
                //     acceleration = math. multiply(acceleration, 0.1);
                // }
                //
                // agent.vel = math.add(agent.vel, acceleration);
                // agent.vel = normalize(agent.vel);
                // continue;
                //
                // if (agent.pos[0] >= 380 || agent.pos[0] <= 0) {
                //     agent.targetVel = [-1 * agent.vel[0], agent.vel[1]];
                // }
                //
                // if (agent.pos[1] >= 380 || agent.pos[1] <= 0) {
                //     agent.targetVel = [agent.vel[0], -1 * agent.vel[1]];
                // }


                // agent.pos = math.add(agent.pos, math.multiply(agent.vel, agent.speed_factor));

</script>
</body>
</html>



